<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf8">
    <meta http-equiv="Content-Security-Policy" content=";TODO">
    <link href='http://fonts.googleapis.com/css?family=Inconsolata|Open+Sans' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:900&text=CSP' rel='stylesheet' type='text/css'>
    <style>
      html {
      }
      body {
        background: #EEF1D9;
        font: 15px/1.4 'Open Sans', sans-serif;
        width: 90%;
        max-width: 700px;
        min-width: 550px;
        margin: 0 auto;
      }
      code {
        font: 15px/1.4 'Inconsolata', monospace;
      }

      header::before {
        position: absolute;
        content: "CSP";
        font: 100px/1 'Source Sans Pro';
        font-weight: 900;
        margin-top: -15px;
      }
      header {
        text-align: right;
        color: rgba(0,0,0,0.9);
        border-bottom: 1px solid rgba(0,0,0,0.5);
        padding-bottom: 10px;
      }
      h1 {
        letter-spacing: 1px;
      }
      h1, h2 {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Content Security Policy</h1>
      <h2>Mitigate the risk of XSS attacks.</h2>
    </header>

    <h3>Why should I care?</h3>

    <p>If untrusted JavaScript runs on your site, you're in big trouble.</p>

    <p>
      Cross-site scripting (XSS) attacks rely on a weakness in the web's
      security model, the same-origin policy. In a nutshell, when malicious
      content finds its way onto a page, it has all the same rights and
      privileges to access data on that page's origin as the page's own code.
      Browsers simply can't distinguish code that's intended to be executed
      from code that snuck in through poorly escaped user-generated content.
    </p>
    <p>
      In theory, perfectly escaping all user input would completely prevent XSS
      attacks. In practice, HTML's processing model has become complex enough
      that relying on perfection is inadvisable. Content Security Policy is a
      promising new layer of protection that has the potential to reduce the
      damage that can be done when unexpected content finds its way onto a page.
    <p>

    <h3>How does Content Security Policy work?</h3>

    <p>
      Pages can define policies for themselves that clearly describe the sources
      from which particular types of resources can be loaded.
      <code>example.com</code> might only trust JavaScript from its own CDN, at
      <code>cdn.example.com</code>; it can specify a policy that <em>only</em>
      accepts code from that origin, and ignores attempts to load it in from
      elsewhere.

    <h3>What should I do?</h3>

    <p>
      First and foremost, block inline script by setting a policy that does not
      include <code>'unsafe-inline'</code>. This ensures that even if an
      attacker finds a hole through which to inject code, she'll have a tough
      time doing anything useful with it.
    </p>
    <p>
      This will require you to rework some of your own code to move inline event
      handlers and blocks of inline script out into external files. That is,
      you'll want to replace this:
    </p>
    <pre data-filename="index.html"><code>
&lt;script&gt;
  function doStuff() {
    // [AMAZINGNESS GOES HERE]
  }
&lt;/script&gt;
&hellip;
&lt;a href="javascript:doStuff();"&gt;Click me!&lt;/a&gt;
&lt;button onclick="doStuff();"&gt;Click me!&lt;/a&gt;
    </code></pre>
    <p>
      with this:
    </p>
    <pre data-filename="index.html"><code>
&lt;script src="index.js"&gt;&lt;/script&gt;
&hellip;
&lt;a href="javascript:doStuff();" <ins>id="link1"</ins>&gt;Click me!&lt;/a&gt;
&lt;button onclick="doStuff();" <ins>id="button1"</ins>&gt;Click me!&lt;/a&gt;
    </code></pre>
    <pre data-filename="index.js"><code>
function doStuff() {
  // [AMAZINGNESS GOES HERE]
}

// Once the document's DOM is ready, attach event listeners.
document.addEventListener('DOMContentLoaded', function () {
  document.querySelector('#link1').addEventListener('click', doStuff);
  document.querySelector('#button1').addEventListener('click', doStuff);
});
    </code></pre>
  </body>
