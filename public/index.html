<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf8">
    <meta http-equiv="Content-Security-Policy" content=";TODO">
    <link href='https://fonts.googleapis.com/css?family=Inconsolata|Open+Sans:300italic,400,300,600,800' rel='stylesheet' type='text/css'>
    <link href='starburst.css' rel='stylesheet' type='text/css'>
    <script defer src="prettify.js"></script>
    <script defer src="main.js"></script>
    <style>
      html {
      }
      body {
        background: #EEE;
        font: 16px/1.4 arial, sans-serif;
        width: 90%;
        max-width: 700px;
        min-width: 550px;
        margin: 0 auto;
      }
      code {
        font: 18px/1.4 'Inconsolata', monospace;
        background: #FFF;
        padding: 3px;
      }
      header {
        text-align: left;
        color: rgba(0,0,0,0.9);
        padding: 50px 0;
      }
      h1 {
        font: 40px/1.2 'Open Sans';
        font-weight: 800;
      }
      h2 {
        font: 34px/1 'Open Sans';
        font-weight: 300;
      }
      h1, h2 {
        margin: 0;
      }

      pre {
        background: #333;
        border-radius: 5px;
        color: #EEE;
        padding: 1em;
      }
      pre code {
        font-size: 25px;
        background: transparent;
      }

      a, a:visited {
        color: #145BB8;
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Content Security Policy</h1>
      <h2>Welcome to the post-XSS world</h2>
    </header>
    <nav>
      
    </nav>

    <p>
      If you run an even moderately valuable web site, you're under attack
      almost constantly. You've taken every precaution, properly <a href="https://www.owasp.org/index.php/Data_Validation">validating
      user input</a> and contextually escaping everything you write out to the
      page. However, your advisaries are clever and numerous, and your time and
      attention are limited. You will slip up. A small hole will open. It will
      be discovered and exploited: another successful cross-site scripting. So
      it goes.
    </p>

    <p>Or does it?</p>

    <p>
      If you've protected your site by setting a <strong>Content Security
      Policy</strong>, you'll add significant depth to your defenses. Even if
      an attacker finds and uses a bug to inject content, her exploitation
      options will be sincerely limited. Site defacement or execution of
      untrusted script will be <em>significantly</em> more difficult.
    </p>

    <h2>Content Securawhat?</h2>
    <p>
      The central vulnerability that content-injection attacks rely upon is a
      browser's inability to distinguish between content you've intentionally
      included on a site, and content that's been maliciously injected. That is,
      <code>&lt;script&gt;doSomethingUseful();&lt;/script&gt;</code> looks
      exactly the same to a browser as
      <code>&lt;script&gt;alert('xss');&lt;/script&gt;</code> when included on a
      page. Content Security Policy (CSP) gives you the means to explain your
      intentions more clearly to a browser, providing it with the information
      necessary to make well-founded judgements regarding a specific piece of
      content based on it's origin. A typical policy might read "Allow only
      content that I deliver myself, except for images. Images are fine to load
      from anywhere." Et voil√†, the browser has clear rules it can follow!
      Content that isn't delivered from your origin should be rejected. That's
      easy.
    </p>

    <p>
      A page's policy is best delivered via an especially creatively named HTTP
      header: <code>Content-Security-Policy</code>. For example, the example
      policy described above maps to:
    </p>
    <pre class="prettyprint lang-csp"><code>Content-Security-Policy: default-src 'self';
                         img-src *</code></pre>

    <h3>What should I do?</h3>

    <p>
      First and foremost, block inline script by setting a policy that does not
      include <code>'unsafe-inline'</code>. This ensures that even if an
      attacker finds a hole through which to inject code, she'll have a tough
      time doing anything useful with it.
    </p>
    <p>
      This will require you to rework some of your own code to move inline event
      handlers and blocks of inline script out into external files. That is,
      you'll want to replace this:
    </p>
    <pre data-filename="index.html"><code>
&lt;script&gt;
  function doStuff() {
    // [AMAZINGNESS GOES HERE]
  }
&lt;/script&gt;
&hellip;
&lt;a href="javascript:doStuff();"&gt;Click me!&lt;/a&gt;
&lt;button onclick="doStuff();"&gt;Click me!&lt;/a&gt;
    </code></pre>
    <p>
      with this:
    </p>
    <pre data-filename="index.html"><code>
&lt;script src="index.js"&gt;&lt;/script&gt;
&hellip;
&lt;a href="javascript:doStuff();" <ins>id="link1"</ins>&gt;Click me!&lt;/a&gt;
&lt;button onclick="doStuff();" <ins>id="button1"</ins>&gt;Click me!&lt;/a&gt;
    </code></pre>
    <pre data-filename="index.js"><code>
function doStuff() {
  // [AMAZINGNESS GOES HERE]
}

// Once the document's DOM is ready, attach event listeners.
document.addEventListener('DOMContentLoaded', function () {
  document.querySelector('#link1').addEventListener('click', doStuff);
  document.querySelector('#button1').addEventListener('click', doStuff);
});
    </code></pre>
  </body>
